searchState.loadedDescShard("auradb", 0, "AuraDB - High-performance Rust storage engine\nCommon imports for the crate\nMain AuraDB engine implementation\nMain engine trait defining the core KV operations\nEngine builder for easy configuration\nEngine options\nDatabase snapshot\nBuild the engine\nClose the engine\nWhether to create directories if they don’t exist\nSnapshot data\nDelete a key\nDelete a string key (convenience method)\nWhether to error if database already exists\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a value by key\nGet a value by key using Vec (for benchmarks)\nGet a string value by key (convenience method)\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new engine builder\nCreate a new engine instance\nSet the database path\nDatabase path\nPut a key-value pair\nPut a key-value pair using Vec (for benchmarks)\nPut a string key-value pair (convenience method)\nScan a range of keys\nScan string keys in a range (convenience method)\nCreate a snapshot\nTimestamp when snapshot was created\nWrite a batch of operations\nWrite a batch of key-value pairs\nARC (Adaptive Replacement Cache)\nAdaptive Radix Tree (ART)\nB-tree implementation\nBinary search\nBloom filter + scan\nCache configuration\nCompaction configuration\nCompaction strategy\nCompaction trigger thresholds\nCompression algorithms\nConfiguration for the AuraDB storage engine\nSync every N milliseconds\nSync every N writes\nSync every write (safest, slowest)\nCache eviction policy\nFallback search method when learned index fails\nFence pointers\nFlexible LSM (FLSM) - can switch between strategies\nLearned index configuration\nLeveled compaction (RocksDB-style)\nLRU (Least Recently Used)\nLz4 compression (fast)\nManual sync only\nMemtable configuration\nMemtable implementation type\nLearned index model type\nNo compression\nPerformance tuning configuration\nPiecewise linear regression\nRL agent configuration\nRecursive Model Index (RMI)\nSkip list implementation\nSnappy compression (balanced)\nSST (Sorted String Table) configuration\nTiered compaction\nTinyLFU\nTiny neural network\nValue log configuration for WAL-time KV separation\nWAL (Write-Ahead Log) configuration\nWAL sync policy\nZstandard compression (good compression ratio)\nWhether to use async WAL writes\nBlock cache size in bytes\nBlock size in bytes\nBloom filter bits per key\nWAL buffer size in bytes\nCache configuration\nValue log cache size in bytes\nCompaction configuration\nWhether to compress values\nCompression algorithm for SST blocks\nCompression algorithm\nNumber of memtables\nDatabase directory path\nWhether to use direct I/O\nWhether to enable learned indexes\nWhether to enable RL agent\nCache eviction policy\nExploration rate (epsilon)\nFallback search method\nFlush threshold (percentage of max_size)\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nMemtable implementation\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nI/O buffer size\nI/O rate limit in MB/s\nLearned index configuration\nLearning rate\nLevel 0 file count threshold\nLevel size ratio threshold\nMaximum WAL file size in bytes\nMaximum segment size in bytes\nMaximum memtable size in bytes\nMaximum number of background threads\nWhether to use memory-mapped files\nMemtable configuration\nModel type to use\nCreate a new configuration with default values\nNUMA awareness\nWhether to use offline training\nWhether to use online tuning\nPerformance tuning\nRL agent configuration\nValue size threshold for separation (bytes)\nSST configuration\nSST directory path\nState update frequency\nCompaction strategy\nWAL sync policy\nTarget file size in bytes\nTraining data path\nTraining frequency (every N operations)\nCompaction trigger thresholds\nWhether to use unified cache\nWhether to use Bloom filters\nWhether to use Ribbon filters\nWhether to use RL-driven compaction\nValidate the configuration\nValue log configuration\nValue log cache size in bytes\nValue log directory path\nWAL configuration\nWAL directory path\nSet cache configuration\nSet compaction configuration\nSet the database path\nSet learned index configuration\nSet memtable configuration\nSet performance configuration\nSet RL agent configuration\nSet SST configuration\nSet value log configuration\nSet WAL configuration\nNumber of worker threads\nWrite amplification threshold\nNumber of parallel write queues\nContains the error value\nError types for AuraDB operations\nContains the success value\nResult type for AuraDB operations\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA batch of operations\nDelete operation\nA key-value pair entry\nA key in the storage engine\nMerge operation\nOperation types for entries\nPut operation\nA range for scan operations\nA value in the storage engine\nA value pointer for WAL-time KV separation Points to a …\nAdd an operation to the batch\nGet the key as bytes\nGet the value as bytes\nOptional checksum\nOptional checksum for validation\nCreate a compressed value\nOptional compression info\nThe actual key bytes\nThe actual value bytes\nCreate a delete entry\nEnd key (exclusive)\nGet the end offset (offset + length)\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCheck if this entry has an inline value\nCheck if this entry has a value pointer\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if this is a delete operation\nCheck if key is empty\nCheck if value is empty\nCheck if batch is empty\nCheck if this is a “large value” that should go to …\nCheck if this pointer is valid\nThe key\nGet the key length\nGet the value length\nGet the number of operations\nLength of the value\nMaximum number of entries to return\nOptional user-defined metadata\nCreate a new key from bytes\nCreate a new value from bytes\nCreate a new value pointer\nCreate a new entry with an inline value\nCreate a new empty batch\nCreate a new range\nOffset within the segment\nOperation type\nThe operations in this batch\nSegment ID in the value log\nSequence number for MVCC\nBatch sequence number\nStart key (inclusive)\nWhether this batch should be synced\nTimestamp\nThe value (if not using value log) or value pointer\nThe value pointer (if using value log)\nCreate a value pointer with checksum\nSet a limit on the number of entries\nCreate a key with metadata\nCreate a new entry with a value pointer\nSet the batch sequence number\nSet whether this batch should be synced")